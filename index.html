<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Matrix</title>
    <link rel="preload" href="matrix.ttf" as="font" type="font/ttf">
    <style media="screen">
      @font-face { font-family: matrix; src: url(matrix.ttf); }
      html,body { margin: 0; background: #000; overflow: hidden;}
      #root { color: rgb(182,255,161); position: relative; overflow: hidden; font-family: matrix, sans-serif; font-weight: bold; display: flex; align-items: center; justify-content: center; flex-wrap: nowrap; }
      #root > span { position: relative; }
      #root > span > span { color: transparent; font-size: 11px; width: 12px; height: 12px; display: flex; align-items: center; justify-content: center; }
      #root > span > span.active { color: #ffffd1; text-shadow: 0 0 4px #ffffd1; font-family: sans-serif; font-weight: bold; }
    </style>
    <script type="text/javascript">

    const createNode = (options) => {
      const node = document.createElement(options.tag);
      if(options.className) node.setAttribute('class',options.className);
      if(options.innerHTML) node.innerHTML = options.innerHTML;
      if(options.cssText) node.style.cssText = options.cssText;
      options.root.appendChild(node);
      return node;
    }

    class Glyph {
      constructor(options){
        this.glyphs = ['モ','エ','ヤ','キ','オ','カ','7','ケ','サ','ス','z','1','5','2','ヨ','タ','ワ','4','ネ','ヌ','ナ','9','8','ヒ','0','ホ','ア','3','ウ',' ','セ','¦',':','"','꞊','ミ','ラ','リ','╌','ツ','テ','ニ','ハ','ソ','▪','—','<','>','0','|','+','*','コ','シ','マ','ム','メ'];
        this.current = Math.floor(Math.random()*this.glyphs.length);
        this.position = options.position;
      }
      get(){
        return this.glyphs[this.current];
      }
    }

    class Column {
      constructor(options){
        window.addEventListener('resize',this.reset.bind(this));
        this.letter = options.letter;
        this.rows_center = options.rows_center;
        this.position = options.position;
        this.max_rows = options.max_rows;
        this.overflow = this.max_rows + 40;
        this.drop_position = Math.floor(Math.random()*this.max_rows);
        this.drop_speed = Math.floor(Math.random() * (100 - 30) + 30);
        this.glyphs = [];
        for(let i = 1; i < this.max_rows; i++){
          const glyph = new Glyph({ position: i });
          const glyph_el = createNode({ root: options.root, tag: 'span', innerHTML: glyph.get(), cssText: `color: transparent`});
          this.glyphs.push({ node: glyph_el, glyph: glyph });
        }
        this.interval = setInterval(() => {
          this.drop();
        }, this.drop_speed )
      }
      reset(){
        clearInterval(this.interval);
      }
      drop(){
        this.drop_position = this.drop_position > this.overflow ? 0 : this.drop_position + 1;
        this.glyphs.forEach(glyph => {
          if(glyph.node.classList.contains('active')) return;
          if(glyph.glyph.position < this.drop_position){
            const alpha = 0.8 - ((this.drop_position - glyph.glyph.position) * 0.025)
            glyph.node.style.cssText = `color: rgba(180,255,160,${alpha}); text-shadow: 0 0 4px rgba(180,255,160,${alpha})`;
          } else if(glyph.glyph.position > this.drop_position ){
            glyph.node.style.cssText = `color: transparent`;
          } else {
            if(this.letter && glyph.glyph.position === this.rows_center){
              glyph.node.classList.add('active');
              glyph.node.innerHTML = this.letter;
            }
            glyph.node.style.cssText = `color: #ffffd1; text-shadow: 0 0 4px #ffffd1`;
          }
        })
      }
    }

    class Matrix {
      constructor(){
        document.addEventListener('DOMContentLoaded',this.init.bind(this));
        window.addEventListener('resize',this.init.bind(this));
        this.root = null;
        this.message = 'GITHUB.COM/IAMJOHNMILLS';
      }
      async init(){
        this.root = document.getElementById('root');
        this.root.innerHTML = ``;
        const glyph_size = 12;
        const max_columns = Math.ceil(window.innerWidth / glyph_size);
        const max_rows = Math.ceil(window.innerHeight / glyph_size);
        const message_parts = this.message.split('');
        const rows_center = Math.floor(max_rows / 2);
        const columns_center = Math.floor(max_columns / 2);
        const message_start = columns_center - (Math.floor(message_parts.length / 2));
        const message_letters = message_parts.map( (message_part,i) => ({ position: message_start + i, letter: message_part }))
        for(let i = 1; i < max_columns; i++){
          const letter = message_letters.find(message_letter => message_letter.position === i);
          const column_el = createNode({ root: this.root, tag: 'span' });
          const column = new Column({ root: column_el, rows_center: rows_center, letter: letter ? letter.letter : null, max_rows: max_rows, position: i })
        }
      }
    }

    const matrix = new Matrix();

    </script>
  </head>

  <body>
    <div id="root"></div>
  </body>
</html>
