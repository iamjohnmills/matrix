<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title>Matrix</title>
    <link rel="preload" href="matrix.ttf" as="font" type="font/ttf">
    <style media="screen">
      @font-face { font-family: matrix; src: url(matrix.ttf); }
      html,body { margin: 0; background: #000; overflow: hidden;}
      #root { color: rgb(182,255,161); position: relative; overflow: hidden; font-family: matrix; display: flex; align-items: center; justify-content: center; flex-wrap: nowrap; }
      #root > span { position: relative; }
      #root > span > span { font-size: 11px; width: 12px; height: 12px; display: flex; align-items: center; justify-content: center; }
    </style>
    <script type="text/javascript">

    const createNode = (root,tag) => {
      const node = document.createElement(tag);
      if(root) root.appendChild(node);
      return node;
    }

    class Glyph {
      constructor(options){
        this.glyphs = ['モ','エ','ヤ','キ','オ','カ','7','ケ','サ','ス','z','1','5','2','ヨ','タ','ワ','4','ネ','ヌ','ナ','9','8','ヒ','0','ホ','ア','3','ウ',' ','セ','¦',':','"','꞊','ミ','ラ','リ','╌','ツ','テ','ニ','ハ','ソ','▪','—','<','>','0','|','+','*','コ','シ','マ','ム','メ'];
        this.current = Math.floor(Math.random()*this.glyphs.length);
        this.position = options.position;
      }
      get(){
        return this.glyphs[this.current];
      }
    }

    class Column {
      constructor(options){
        this.position = options.position;
        this.max_rows = options.max_rows;
        this.drop_position = Math.floor(Math.random()*this.max_rows);
        // this.drop_speed = Math.floor(Math.random() * (100 - 30) + 30);
        this.drop_speed = Math.random() * (0.5 - 0.1) + 0.1;
        this.glyphs = [];
        for(let r = 1; r < this.max_rows; r++){
          const glyph = new Glyph({ position: r });
          const glyph_el = createNode(options.root,'span');
          glyph_el.innerHTML = glyph.get();
          glyph_el.style.color = 'transparent';
          this.glyphs.push({ node: glyph_el, glyph: glyph });
        }
        window.requestAnimationFrame(this.handleRequestAnimationFrame.bind(this))
        // this.interval = setInterval(async () => {
        // }, this.drop_speed )
      }
      handleRequestAnimationFrame(){
        this.drop();
        window.requestAnimationFrame(this.handleRequestAnimationFrame.bind(this));
      }
      drop(){
        this.drop_position = this.drop_position + this.drop_speed > this.max_rows + 40 ? 0 : this.drop_position + this.drop_speed;
        const closest = this.glyphs.reduce((a, b) => {
          return Math.abs(b.glyph.position - this.drop_position) < Math.abs(a.glyph.position - this.drop_position) ? b : a;
        });
        this.glyphs.forEach(glyph => {
          if(glyph.glyph.position === closest.glyph.position && glyph.glyph.position < this.max_rows - 1){
            glyph.node.style.color = `#ffffd1`;
          } else if(glyph.glyph.position < this.drop_position){
            const alpha = 0.8 - ((this.drop_position - glyph.glyph.position) * 0.025)
            glyph.node.style.color = `rgba(182,255,161,${alpha})`;
          } else if(glyph.glyph.position > this.drop_position ){
            glyph.node.style.color = `rgba(0,0,0,0)`;
          }
        })
      }
    }

    class Matrix {
      constructor(){
        document.addEventListener('DOMContentLoaded',this.init.bind(this));
        window.addEventListener('resize',this.init.bind(this));
        this.intervals = [];
        this.root = null;
      }
      async reset(){
        await this.intervals.every(interval => { clearInterval(interval); return true; } )
        this.intervals = [];
        this.root = document.getElementById('root');
        this.root.innerHTML = ``;
      }
      async init(){
        await this.reset();
        const glyph_size = 12;
        const max_columns = Math.ceil(window.innerWidth / glyph_size);
        const max_rows = Math.ceil(window.innerHeight / glyph_size);
        for(let c = 1; c < max_columns; c++){
          const column_el = createNode(this.root,'span');
          const column = new Column({ root: column_el, max_rows: max_rows, position: c })
        }
      }
    }

    const matrix = new Matrix();

    </script>
  </head>

  <body>
    <div id="root"></div>
  </body>
</html>
